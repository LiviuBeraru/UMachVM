\section{Architektur}

\subsection{Maschinentyp}

\begin{frame}[fragile]{\insertsubsection}
 \begin{itemize}
  \item UMach ist eine registerbasierte RISC Maschine.\\
        
        Wenige Befehle (69) mit fester Länge.        
  \item Load/Store Speicherzugriff über Registerangabe.
\begin{lstlisting}
LW   R1 R2 # R1 $\gets$ mem(R2)
SW   R1 R2 # R1 $\to$ mem(R2)
\end{lstlisting}
  \item Port I/O
\begin{lstlisting}
IN  R17 R18 R19
OUT R1  R2  R3
\end{lstlisting}
  \item Keine Pipeline
  \item Big endian
 \end{itemize}
\end{frame}


\subsection{Register}

\begin{frame}{\insertsubsection}
 Die UMach Maschine hat 32 Allzweckregister
 und 13 Spezialregister.
 
 Jedes Register ist genau 32 Bit lang.
 
 Die Register werden intern durch Nummern identifiziert:
 Register Nummer 0, Nummer 1, Nummer 2\ldots{} Nummer 44.
\end{frame}


\subsubsection{Allzweckregister}

\begin{frame}{\insertsubsubsection}
 Die Register mit Nummern 1 bis 32 können frei verwendet werden.
 Sie werden von der Maschine ohne explizite Anweisung nicht geändert, außer
 dass sie beim Start der Maschine mit dem Wert Null belegt werden.

 Die Allzweckregister haben die Namen $R1$, $R2$, \ldots{} $R32$.
 
 Register mit den Namen $R0$ und $R33$ gibt es nicht.
\end{frame}



\subsubsection{Spezialregister}

\begin{frame}{\insertsubsubsection}
 Dienen der Steuerung der Maschine und haben besondere Aufgaben. Sie werden von
 der Maschine verändert.
 
 Die meisten sind schreibgeschützt.
\end{frame}

\begin{frame}{\insertsubsubsection{} - Liste}
 \begin{tabular}{lcl}
Name  & Nummer & Beschreibung \\\toprule
PC    & 33     & Program Counter   \\ 
DS    & 34     & Data Section (begin)   \\ 
HS    & 35     & Heap Section (first byte)   \\ 
HE    & 36     & Heap Section (last byte)   \\ 
SP    & 37     & Stack Pointer   \\ 
FP    & 38     & Frame Pointer  \\ 
IR    & 39     & Instruction Register   \\ 
STAT  & 40     & Status Register   \\ 
ERR   & 41     & Error Register   \\ 
HI    & 42     & Higher 32 Bits (Division, Multiplik.)   \\ 
LO    & 43     & Lower 32 Bits (Division, Multiplik.)   \\ 
CMPR  & 44     & Ergebniss von CMP   \\ 
ZERO  & 0      & Immer konstant Null   \\\bottomrule
 \end{tabular}
\end{frame}




\subsection{Befehle}

\begin{frame}{\insertsubsection}
 Ein Befehl ist immer 32 Bits lang (4 Byte), auch wenn er keine Argumente nimmt
 (RISC Architektur).
 Erstes Byte ist der Befehl, die anderen 3 Bytes sind eventuelle Argumente.
 \begin{center}
  \input{./Arch/befehl0}
 \end{center} 
\end{frame}



\subsection{Befehlsformate}

\begin{frame}{\insertsubsection}
 Wie MMIX von Knuth, hat UMach mehrere Befehlsformate, d.h. mehrere Arten, wie
 man die Argumente einteilen und interpretieren kann.
 
 Manche Befehle erwarten Registernummern, andere direkte nummerische Angaben
 verschiedener Längen, andere eine Mischung davon, andere keine Argumente.
\end{frame}


\begin{frame}{\insertsubsection}
 \begin{center}
  \begin{tabular}{l||c|c|c}
    \toprule
    Format & zweites Byte  & drittes Byte  & viertes Byte \\\toprule
    000 & \multicolumn{3}{c}{nicht verwendet}           \\\midrule
    NNN & \multicolumn{3}{c}{3 Bytes Zahl}              \\\midrule
    R00 & $R_{1}$ & \multicolumn{2}{c}{nicht verwendet} \\\midrule
    RNN & $R_{1}$ & \multicolumn{2}{c}{2 Bytes Zahl}    \\\midrule
    RR0 & $R_{1}$ & $R_{2}$ &  nicht verwendet           \\\midrule
    RRN & $R_{1}$ & $R_{2}$ &  1 Byte Zahl               \\\midrule
    RRR & $R_{1}$ & $R_{2}$ & $R_{3}$                    \\\bottomrule
  \end{tabular}
\end{center}
($R_{1}$, $R_{2}$, $R_{3}$: erste, zweite, dritte Registernummer)

Alle Zahlenangaben: big endian.
\end{frame}



\begin{frame}{\insertsubsection{} - Beispiel RRR}
 \texttt{ADD}: drei Registernummern.
 \begin{center}
  \input{./Arch/befehl1}
 \end{center}
\end{frame}

\begin{frame}{\insertsubsection{} - Beispiel RNN}
 \texttt{DIVI}: eine Registernummer und eine 2-Byte Zahl.
 \begin{center}
  \input{./Arch/befehl2}
 \end{center}
\end{frame}

\begin{frame}{\insertsubsection{} - Beispiel NNN}
 \texttt{JMP}: ein 3-Byte Offset (vorzeichenbehaftet).
 \begin{center}
  \input{./Arch/befehl3}
 \end{center}
\end{frame}

\subsection{Befehlsmenge}

\begin{frame}{\insertsubsection}
\begin{enumerate}
  \item Kontrollinstruktionen: \texttt{NOP}, \texttt{EOP}
  \item Lade- und Speicherbefehle: 
        \texttt{SET}, \texttt{LW}, \texttt{SB}, \texttt{PUSH}
  \item Arithmetische Instruktionen:
        \texttt{ADD}, \texttt{SUB}, \texttt{INC}
  \item Logische Instruktionen:
        \texttt{AND}, \texttt{XOR}, \texttt{SHL}, \texttt{ROTL}
  \item Vergleichsinstruktionen:
        \texttt{CMP}, \texttt{CMPI}
  \item Sprunginstruktionen:
        \texttt{JMP}, \texttt{BE}, \texttt{BL}
  \item Unterprogramminstruktionen:
        \texttt{CALL}, \texttt{RET}, \texttt{GO}
  \item Systeminstruktionen:
        \texttt{INT}
  \item I/O Instruktionen:
        \texttt{IN}, \texttt{OUT}
\end{enumerate}
Insgesamt 69 Befehle.
\end{frame}



\subsection{Speichermodell}

\begin{frame}{\insertsubsection}
 Der Speicher der UMach Maschine enthält hauptsächlich
 \begin{itemize}
  \item Programmcode
  \item Programmdaten
  \item Freier Speicher
 \end{itemize}
  Kein Memory Mapped I/O.
  
  Gesamte Speichergröße ist nach dem Start der Maschine fest.
\end{frame}


\begin{frame}{Segmente}
 Der Speicher wird in Segmenten eingeteilt.
 \begin{enumerate}
  \item Interrupttabelle
  \item Programmcode (Code-Segment)
  \item Programmdaten (Daten-Segment)
  \item Heap (Freispeicher)
  \item Stack (Lokaler Speicher)
 \end{enumerate}
 Der Code- und Daten-Segment werden aus der Programmdatei geladen. 
 Der Rest ist dynamisch und kann durch Register (\texttt{HE}, \texttt{SP})
 oder Befehle (\texttt{PUSH}, \texttt{POP}) manipuliert werden.
\end{frame}


\begin{frame}[fragile]{Heap und Stack Manipulieren}
 \begin{lstlisting}
  ADDI HE HE 128
  # ...
  SUBI HE HE 128
 \end{lstlisting}
 Speicher auf dem Heap reservieren erfolgt dadurch, dass der Inhalt des
 Registers \texttt{HE} (Heap End) hochgezählt wird. Speicher freigeben durch
 runterzählen.
 
 \begin{lstlisting}
  SUBI SP SP 32
  # ...
  ADDI SP SP 32
 \end{lstlisting}
 Lokaler Speicher wird durch Veränderung des Registers \texttt{SP} (Stack
 Pointer) erreicht.
\end{frame}


\begin{frame}{Speicher-Layout}
 \begin{center}
  \input{./Arch/speicher}
 \end{center}
 Segmentation Fault: schreiben in Code-Segment.
 
 Stack Overflow: Befehl \texttt{PUSH} führt zum Überlappen der Register
\texttt{SP} und \texttt{HE}.
\end{frame}



\subsection{I/O}

\begin{frame}{Port I/O}
 Die UMach Maschine verwendet Port I/O, d.h. sie hat Befehle zum Ausgeben und
 Einlesen von Daten. Es werden Ports verwendet: durchnummerierte Ausgänge und
 Eingänge.
\end{frame}

\begin{frame}{Ports}
 Es gibt 8 Ausgabeports und 8 Eingabeports, die jeweils von 0 bis 7
 durchnummeriert sind.
 
 Ausgabeport 0: \texttt{stdout}.
 
 Eingabeport 0: \texttt{stdin}.
\end{frame}


\begin{frame}{Transfer}
 Der Datentransfer findet direkt zwischen Speicher und I/O-Ports statt.
 Der Transfer blockiert die Maschine solange der Transfer noch nicht fertig ist.
 
 Die I/O-Befehle haben das Format RRR (drei Registernummern).
\end{frame}


\begin{frame}{Ausgabe}
 Die Ausgabe erfolgt durch verwendung des Befehls \texttt{OUT}
 \begin{center}
  \input{./Arch/io0}
 \end{center}
\end{frame}


\begin{frame}{Eingabe}
 Die Eingabe erfolgt durch verwendung des Befehls \texttt{IN}
 \begin{center}
  \input{./Arch/io1}
 \end{center}
\end{frame}


\subsection{Interrupts}

\begin{frame}{\insertsubsection}
 Unterbrechungen im normalen Programmfluss, die mit einer Interruptnummer
 versehen sind und die abgefangen werden können. 
 Analog zu \glqq exceptions\grqq{} in Java/C++.
 
 Abfangen heißt, dass eine Subroutine mit der Interruptnummer verbunden wird.
 
 Ist ein Interrupt nicht mit einer Subroutine verbunden, so stoppt die Maschine
 wenn der Interrupt passiert.
\end{frame}



\begin{frame}{Arten von Interrupts}
 \begin{enumerate}
  \item Hardware-Interrupts: wenn etwas schief mit einem Befehl geht:
        Division durch Null, Stack Overflow, falsche Befehlsnummer, ungültige
        Speicheraddresse, schreiben in das Codesegment, etc.
  \item Software-Interrupts: werden vom Programmierer durch den Befehl 
        \texttt{INT} angestoßen.
 \end{enumerate}
\end{frame}


\begin{frame}{Interrupttabelle}
 Die Interrupttabelle startet an der Addresse Null und besteht aus 64 Einträgen,
 jeweils 32 Bit groß (=256 Bytes).
 
 Jeder der $64$ Einträge entspricht einer Interruptnummer.
 
 Interrupt 26 $\to$ Adresse $26 \cdot 4 = 104$.
 
 An jedem Index steht entweder Null oder die Addresse einer Subroutine
 (Interrupt Handler). Diese wird ausgeführt, wenn der entsprechende Interrupt
 generiert wird.
 
 Adresse des Interrupt Handlers ist Null $\mapsto$ Maschine ausschalten.
\end{frame}



\begin{frame}{Wie läuft ein Interrupt ab}
 \begin{center}
  \input{./Arch/interrupt0}
 \end{center}
\end{frame}



\section{Implementierung}

\subsection{Programmablauf}

\begin{frame}[fragile]{\insertsubsection}
 Die Maschine hat grundsätzlich zwei Schritte, die sie immer wieder wiederholt: 
 fetch und execute. 
 \begin{lstlisting}
void core_run_program(void)
{
    while (running) {
        core_fetch();
        core_execute();
    }
}
 \end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Fetch}
 Fetch: die nächste Instruktion aus dem Speicher holen.
\begin{lstlisting}
void core_fetch(void)
{
    if (! running) { return; }
    mem_read               // read from mem
    ( instruction,         // whereto
      registers[PC].value, // wherefrom
      4                    // how much
    );
}
\end{lstlisting}
Lese 4 Bytes aus dem Speicher ab der Adresse \texttt{PC} in den
Puffer \texttt{instruction}.

Nach \texttt{fetch} steht der neue Befehl im globalen Array
\texttt{instruction[4]}. (big endian)
\end{frame}



\begin{frame}[fragile]{Execute}
 Befehl ausführen und \texttt{PC} inkrementieren.
\begin{lstlisting}
struct command *cmd = 
       command_by_opcode(instruction[0]);
if   (cmd != NULL) 
     { cmd->opfunc();              } 
else { interrupt(INT_INVALID_CMD); }
registers[PC].value += 4;
\end{lstlisting}

Es wird nach einem Funktionszeiger gesucht, der dem Befehlscode entspricht
(die Funktion implementiert den Befehl).
Fall vorhanden, ausführen. Falls nicht, Interrupt generieren.

(Der Funktionszeiger ist in einer Struktur \texttt{command} gepackt.)
\end{frame}


\subsection{Sprungtabellen}

\begin{frame}{\insertsubsection}
 Wie wird schnell nach einem Funktionszeiger gesucht?
 
 Mit Sprungtabellen: ein Array von Funktionszeigern in Strukturen gepackt, wo
 jede Struktur genau an dem Index steht, der gleich dem entsprechenden
 Befehlscode ist.
 
 Suchaufwand $O(1)$. Schneller geht's nicht.
\end{frame}


\begin{frame}[fragile]{\insertsubsection{} -- Auszug}
\begin{lstlisting}
struct command opmap[OPMAX] = {
    [0x00] = {0x00, "NOP", core_nop ,NUL},
    [0x04] = {0x04, "EOP", core_eop ,NUL},
    [0x10] = {0x10, "SET", core_set ,RNN},
    ....
    [0x90] = {0x90, "GO" , core_go  ,R00},
    [0x91] = {0x91, "CALL, core_call,NNN},
    [0x92] = {0x92, "RET", core_ret ,NUL},
    [0xA0] = {0xA0, "INT", core_int ,NNN},
    [0xB0] = {0xB0, "IN" , core_in  ,RRR},
    [0xB8] = {0xB8, "OUT", core_out ,RRR}
};
\end{lstlisting}
(C99 Magie.)
\end{frame}

\begin{frame}[fragile]{Suchen in der Sprungtabelle}
 Wie findet mal die Funktion, die einem Befehlscode entspricht?
\begin{lstlisting}
struct command* command_by_opcode
(int opcode)
{  
    if (opmap[opcode].opname) {
        return & opmap[opcode];
    } else {
        return NULL;
    }
}
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Ein Beispiel: \texttt{ADD}-Befehl}
Eintrag in der Sprungtabelle:
\begin{lstlisting}
[0x30] = {0x30, "ADD", core_add, RRR}
\end{lstlisting}

Der Befehl \texttt{ADD} hat die Befehlsnummer \texttt{0x30} und die Funktion
\texttt{core\_add} steht am Index \texttt{0x30} in der Sprungtabelle.
\end{frame}


\begin{frame}[fragile]{\texttt{ADD} -- Implementierung}
\begin{lstlisting}
int core_add(void) {
    int32_t a = 0; 
    int32_t b = 0;

    read_register  (instruction[2], &a   );
    read_register  (instruction[3], &b   );
    write_register (instruction[1], a + b);       
    return 0;
}
\end{lstlisting}
(Veränderte Version, Error Checks gelöscht).
\end{frame}



