Vorsicht! Nicht mehr aktuell
==================================
    Compilieren und Ausführen
==================================

Die Maschine kann mit dem Programm make compiliert werden. Dazu verwendet man
einen der folgenden Befehlen:
    make
    make umach
Dabei wird eine Datei namens 'umach' erzeugt, die ausgeführt werden kann. 
Um die Maschine zu starten, verwendet man also
    ./umach [optionen] <program>

Die Angabe von Optionen ist nicht erforderlich.

--- Optionen ---

Das Programm umach kann mit den folgenden Optionen gestartet werden:

-v
    Inkremetiert die 'Verbosity'-Stufe. Je höher diese Stufe, desto mehr
    Informationen werden während der Ausführung ausgegeben. Kann wiederholt
    angegeben werden.

-d
    Startet die Maschine in Debug-Modus. Dabei wird das angegebene Programm
    schrittweise ausgeführt.

-m <nbytes>
    Spezifiziert die Größe des Speichers in Bytes. Voreingestellt sind 512
    Bytes.

-s
    Disassebmliert das angegebene Program. Dabei wird das Programm nicht
    ausgeführt.

==================================
    Dateien
==================================

Die Dateien, die die Umach Maschine implementieren, sind mehr oder weniger
logisch wie folgt strukturiert.

--- Maschinen-Komponenten ---

Die Hauptmodule core.c und memory.c implementieren den UMach-Kern und den
Speicher. Die I/O Einheit wird nicht in einer eigene Datei implementiert, da
ihre Funktionalität in den I/O Befehlen implementiert wird.

* core.c, core.h
    Allgemeine Funktionen, die sich auf den Kern beziehen. Hier werden auch die
    Register definiert - bzw. Speicher dafür allokiert.

* memory.c, memory.h
    Implementiert den Speicher (read/write Funktionen)

* core_state.h
    Deklariert eine Struktur, die den jetzigen Zustand der Maschine beschreibt.
    Die Idee dabei ist, dass die Befehle den Zustand der Maschine verändern. Sie
    sollten entsprechend Zufriff auf diesen Zustand haben. Die Zustandstruktur
    wird getrennt deklariert (also nicht in core.h), damit die Funktionen, die
    einen Zugriff auf diesen Zustand brauchen nicht gleich Zugriff auf alle
    Kern-Funktionen erhalten.
    Für die einzelnen Zustandskomponenten siehe die Dokumentation, die in der
    Datei selbst enthalten ist.

* core_register.h
    Deklariert die Struktur, die ein Register darstellt. Es wird eine Struktur
    verwendet, um alle Informationen betreffend ein Register an einer Stelle
    zusammenzufügen. Diese Struktur wird in core.c verwendet, um die Liste der
    Register zu definieren. Sie wird auch überall dort verwendet, wo Register
    angesprochen werden müssen.


--- ISA Definition ---

* command.c, command.h
    Definiert in einer statischen Tabelle alle opcodes, deren
    Instruktionsformate, Assemblernamen und die Funktion, die den opcode (Befehl)
    implementiert. Diese Tabelle wird während der Ausführung eines Programms
    verwendet, um die Funktion zu jedem opcode zu finden.
    Da alle diese Informationen an einer einzigen Stelle statisch definiert
    sind, kann man recht einfach den Assembler und Disassembler implementieren,
    ohne zusätzliche Tabellen.
    command.h enthält die Definition der Struktur, die alle Informationen zu
    einem Befehl enthält und command.c definiert die Tabelle.

* interrupts.h
    Definiert als Makros die Interruptnummer. Die interrupt Funktion selbst wird
    in der Datei system.c implementiert.

* registers.h
    Deklariert als Makros alle Registernummer der Spezialregister.


--- ISA Dateien ---

Die folgenden Dateien implementieren die Befehle, die die Maschine erkennt und
ausführen kann (instruction set). Jeder Befehl wird in einer Funktion
implementiert, die dem Befehlsnamen entspricht und die mit 'core_' anfängt. So
wird der Befehl 'ADD' in der Funktion 'core_add' implementiert. Siehe die
Spezifikation für die einzelnen Befehle.

* controll.c, controll.h
    Kontrollinstruktionen

* loadstore.c, loadstore.h
    Load/Store Befehle

* arithm.c, arithm.h
    Arithmetische Befehle

* logic.c, logic.h
    Logische Befehle und Shiften

* compare.c, compare.h
    Vergleichsbefehle

* branch.c, branch.h
    Übersprungsbefehle werden hier implementiert und deklariert

* subroutine.c, subroutine.h
    Unterprogram-Befehle (call, ret)

* system.c, system.h
    Systembefehle (interrupt)

* io.c, io.h
    I/O Befehle


--- Nützliche Dinge ---
Die folgenden Dateien implementieren nützliche Dinge, die mit der
Implementierung zu tun haben und nicht unbedingt in der Spezifikation stehen.

* disassemble.c, disassemble.h
    Funktionen zum disassemblieren einer Instruktion, die als Bytefolge
    angegeben wird. Disassemblieren einer Instruktion wird vom Debugger
    benötigt. Diese Funktionalität wird auch getrennt vom umach Programm
    bereitgestellt (Option -s).

* logmsg.c, logmsg.h
    Ein einfaches Loggingsystem. Die Maschine kann mit verschiedenen
    'Verbose'-Stufen gestartet werden (Option -v). Während der Ausführung eines
    Programms, können Nachrichten erzeugt werden, die abhänging von der
    'Verbose'-Stufe angezeigt werden oder nicht.

* regcheck.c, regcheck.h
    Enthält Makros, die von fast allen Befehl-Funktionen verwendet werden, um
    die Lese- und Schreibrechte eines Registers zu prüfen. Da diese Prüfungen
    sehr oft passieren, wurden sie als Makros implementiert, auch wenn diese
    Makros nicht sehr schön sind.

--- Main ---

* umach.c
    Enthält die main Funktion. Hier werden Optionen geparst und entsprechend die
    Maschine gestartet.

* umach.h
    Deklariert die Struktur, die die globalen Programmoptionen enthält. So kann
    z.B. das Loggingsystem aus logmsg.c diese Optionen nachschlagen, ohne dass
    die Logging-Funktion extra-Parameter dafür braucht.

* umach
    Das ist das ausführbare Programm.


--- Demos ---

* demo/
    Dieses Verzeichnis enthält Demos, die man wie folgt ausführen kann:
        ./umach demo/program

