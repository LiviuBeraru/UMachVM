\section{Assembler}
\begin{flushright}
Werner Linne
\end{flushright}

\subsection{Zielsetzung}

\paragraph{Aufgabe des Assemblers}

Der \emph{uasm} Assembler übersetzt Quelltext in UMach Bytecode und erstellt
Debuginformationen.

\paragraph{Erwünschte Eigenschaften}

Die aus meiner Sicht wichtigsten Eigenschaften des Assemblers sind:
\begin{itemize}
\item \textbf{Effektive Syntax:} Die Syntax des UMach Assemblers soll verständlich
und komfortabel sein. Dadurch wird das Codieren eines UMach Programms erleichtert.

\item \textbf{Performance:} Der Assembler soll auch größere Mengen an Quelltext
mit wenig CPU-Zeit und wenig Arbeitsspeicherbedarf übersetzten können.

\item \textbf{Aussagekräftige Fehlermeldungen:} Bei syntaktischen Fehlern im
Quelltext soll der Benutzer möglichst genau über Art und Position des gefundenen
Fehlers informiert werden.

\item \textbf{Nützliche Debuginformationen:} Der Assembler generiert bei der
Übersetzung des Quelltextes (optional) Debuginformationen. Art und Format dieser
Informationen wurden maßgeschneidert auf die Bedürfnisse des UMach Debuggers
festgelegt.
\end{itemize}

\subsection{Bedienung}

Der Assembler wird über die Befehlszeile bedient. Die Aufrufsyntax ist folgendermaßen
definiert:
\begin{quote}\texttt{uasm [-o outfile] [-g] [-w] file(s)}\end{quote}
Die Bedeutung der einzelnen Elemente wird im folgenden genauer erklärt:

Das \emph{-o} Flag ist optional und benötigt, falls es gesetzt wurde, genau ein
Argument (\emph{outfile}). Das Argument \emph{outfile} steht für den Namen der
Datei, in welche der vom Assembler erzeugte UMach Bytecode geschrieben wird. Ist 
das \emph{-o} Flag nicht gesetzt wird die Datei namens \emph{u.out} verwendet.

Das \emph{-g} Flag steuert die Generierung von Debuginformationen. Ist das Flag
gesetzt werden Debuginformationen generiert, ansonsten nicht.

Das \emph{-w} Flag veranlasst den Assembler im Fehlerfall erst dann zu Terminieren,
nachdem der Benutzer die Eingabetaste gedrückt hat. Dieses Flag wird hauptsächlich
von dem Debugger genutzt.

Das Argument \emph{file(s)} steht für ein oder mehrere Dateien und wir zwingend
benötigt. Der Assembler übersetzt alle in \emph{file(s)} genannten Quelltextdateien
in den UMach Bytecode.

\subsection{Syntax}

Die Syntax von UMach Quelltextdateien ist relativ einfach gestaltet. Wir
unterscheiden zwischen den Abschnitten \emph{Code Section} und \emph{Data Section}.
Jede Quelltextdatei beginnt implizit mit der \emph{Code Section}. Die
\emph{Code Section} beinhaltet Befehle, Sprungmarken, Kommentare und Leerzeilen.
Die \emph{Data Section} ist optional und wird durch die Textzeile ``\emph{.data}''
eröffnet. Die \emph{Data Section} beinhaltet Definitionen von Variablen,
Kommentare sowie Leerzeilen.

Zur Veranschaulichung folgt ein fiktives Beispiel einer UMach Quelltextdatei:

\begin{lstlisting}[numbers=left, numberstyle=\tiny]
SET R1 hello
myloop:
    CALL println #this function is implemented somewhere else
    DEC R2
    CMP R2 ZERO
BNE myloop
#lines containing only a comment or nil are ignored
SET R1 9001
EOP

.data #begin of data definitions
.string hello  "Hello World!\n" #C-style escaping in strings is OK
.int    answer 42
.int    drink  0xCAFE
\end{lstlisting}

In diesem Beispiel bilden die Zeilen 1 bis 10 die \emph{Code Section} und die
\emph{Data Section} wird in Zeile 11 eingeleitet und beinhaltet Zeile 12 bis 14.

Zu beachten sind folgende syntaktischen Regeln:
\begin{itemize}
    \item Es sind beliebig viele Whitespaces (\verb#`\t'# und \verb*#` '#) vor
          und nach Tokens zulässig
    \item Nur Symbolbezeichner (Sprungmarken und Definitionen von Variablen)
          sind case-sensitiv
    \item Symbolbezeichner dürfen keine Zahlenwerte sein
    \item Symbolbezeichner bestehen aus genau einem Wort
    \item Die Definition einer Sprungmarke endet mit \verb#`:'# und steht in
          einer eigenen Zeile im Quelltext
    \item Für alle Dateien gilt der gleiche Namensraum, d.h. namensgleiche
          Symbolbezeichner in verschiedenen Quelltextdateien sind nicht erlaubt
    \item Ab \verb|`#'| beginnt ein Kommentar bis einschließlich \verb#`\n'#
\end{itemize}

\subsection{Implementierung}

Der \emph{uasm} Assembler ist ein 2-pass Assembler, welcher in der
Programmiersprache C99 implementiert ist. Das Programm benötigt lediglich
die GNU~Standard~C~Library (\emph{glibc}) sowie die GNOME~\emph{glib} zur
Compile- und Laufzeit. Der \emph{uasm} Assembler ist ausgelegt und getestet für
die Nutzung auf 32- \& 64-bit Systemen.

Für die Erzeugung des Programms \emph{uasm} benötigt man einen C99 konformen
Compiler (bspw. aktuelle Versionen von \emph{GCC} oder \emph{clang}), das
Programm \emph{GNU make} und die oben genannten Libraries.

\subsubsection{Interne Datenstrukturen}

Eine Hauptaufgabe des Assemblers ist die Übersetzung von Zeichenketten in die
jeweilige UMach Bytecode Repräsentation. Ein solcher Übersetzungsvorgang kann
mithilfe von Hashtables fast immer in $O(1)$ ausgeführt werden. Bei der
Implementierung wurde die Datenstruktur \emph{GHashTable} der \emph{GLib}
verwendet.

Insgesamt kommen drei Hashtables zum Einsatz:
\begin{enumerate}
    \item Eine statische Hashtable zur Übersetzung von Befehlen
    \item Eine statische Hashtable zur Übersetzung von Registern
    \item Eine dynamische Hashtable zur Auflösung von Symbolbezeichner
\end{enumerate}

Bei der Speicherung der Initialisierungswerten von Variablen wird eine
einfach verkettete Liste eingesetzt (\emph{GSList} der \emph{GLib}).
Hierbei ist zu beachten, dass nur performante Funktionen wie
``Einfügen am Anfang'' sowie ``Iteration über alle Elemente'' benötigt werden.
Der Vorteil beim Einsatz der verketteten Liste ist, dass die
Funktion ``Iteration über alle Elemente'' in $O(n)$ realisierbar ist. Bei
Verwendung von \emph{GHashTable} würde der Aufwand für diese Operation hingegen
in $O(n^2)$ liegen.

\subsubsection{Assemblierung}

Der Assembler parst jede Quelltextdatei zweimal (2-pass Assembler). Mithilfe der
im ersten Durchgang gesammelten Informationen ist es dem Assembler möglich, im
zweiten Durchgang den Quelltext Zeile für Zeile zu übersetzen, ohne an manchen
Stellen ``vorauslesen'' zu müssen.

Hier eine genauere Beschreibung der beiden Durchgänge:

\paragraph{Assembler Pass 1}

Im Pass 1 werden folgende Aufgaben erledigt:
\begin{itemize}
    \item Sprungmarken im Quelltext werden erkannt und deren Namen sowie deren
          Zieladressen in die Symboltabelle eingetragen.
    \item Die Codegröße (Summe des Speicherplatzbedarfs aller Befehle) wird
          berechnet.
    \item Die Initialisierungswerte von Variablen werden gespeichert.
    \item Die Adressen von Variablen werden berechnet.
    \item Namen und Adressen von Variablen werden in die Symboltabelle
          eingetragen.
\end{itemize}

\paragraph{Assembler Pass 2}

Im Pass 2 werden folgende Aufgaben erledigt:
\begin{itemize}
    \item Der UMach Bytecode wird generiert und in das \emph{outfile}
          geschrieben.
    \item Die (optionale) Generierung der Debuginformationen.
    \item Initialisierungswerte von Variablen werden in das \emph{outfile}
          geschrieben.
\end{itemize}

\subsubsection{Performance}

Durch die sorgfältige Auswahl der Datenstrukturen und dem Fokus auf performanten
C-Quelltext zeigt der \emph{uasm} Assembler gute Laufzeiteigenschaften.
Die Auflösung von Symbolen erfolgt (mit Ausnahme des Sonderfalls von Kollisionen
in der Hashtable) unabhängig von der Anzahl der gespeicherten Symbolen in
konstanter Zeit, sprich $O(1)$.
Des weiteren wächst die Gesamtlaufzeit einer Assemblierung praktisch linear mit
der Anzahl der zu assemblierenden Quelltextzeilen, sprich $O(n)$.
Der Arbeitsspeicherbedarf wächst linear mit der Anzahl von definierten Symbolen.

In absoluten Zahlen bedeutet dies einen Durchsatz von ca.
$1.4 \times 10^6 \frac{Zeilen}{Sekunde}$, gemessen auf einem
AMD Athlon II X2 250 System mit 3 GHz.

\subsubsection{Fehlerdiagnose}

Falls der vom Benutzer geschriebene Assemblercode syntaktische Fehler enthält,
wird eine Fehlermeldung ausgegeben und die Assemblierung abgebrochen.

Einige Fehlersituationen werden hier anhand von Beispielen genauer diskutiert:
\begin{lstlisting}[numbers=left, numberstyle=\tiny]
echo.uasm, line 1: No such command: <SQRT>
echo.uasm, line 2: Command <CMP> expects RR0: REG REG
echo.uasm, line 3: Unset label <getinput>
echo.uasm, line 4: Not a register: <R77>
echo.uasm, line 6: Label <get_input> already exists
echo.uasm, line 8: No content for <myint> provided
\end{lstlisting}

\begin{description}
    \item[Bsp. 1:] Ein unbekannter Befehl ``SQRT'' wurde verwendet.
    \item[Bsp. 2:] Die Anzahl der Operanden für den Befehl ``CMP'' ist ungültig.
    \item[Bsp. 3:] Es wurde versucht an die unbekannte Sprungmarke ``getinput''
                   zu springen.
    \item[Bsp. 4:] Ein unbekanntes Register ``R77'' wurde als Operand verwendet.
    \item[Bsp. 5:] Die Sprungmarke ``get\_input'' wurde ein zweites mal
                   definiert.
    \item[Bsp. 6:] Bei der Definition der Variable ``myint'' wurde kein
                   Initialisierungswert angegeben.
\end{description}

\subsubsection{Quelltextstruktur}

Der \emph{uasm} Quelltext ist in insgesamt 8 C-Dateien zuzüglich deren
Header-Files aufgeteilt. In der folgenden Tabelle sind die Module genauer
Spezifiziert.

\begin{center}
\begin{tabular}{ll}
C-Datei      & Funktionalität \\
\hline\hline
uasm.c          & \emph{main()} Funktion und Benutzerschnittstelle           \\
assemble.c      & Hauptmodul für das Assemblieren                            \\
asm\_formats.c  & Modul für das Parsen der verschiedenen Befehlsformate      \\
symbols.c       & Modul für die Verwaltung der Symboltabelle                 \\
collect\_data.c & Modul für die Verwaltung der Initialisierungswerten von Variablen \\
commands.c      & Modul für die Zuordnung Befehlsname $\Rightarrow$ OpCode   \\
registers.c     & Modul für die Zuordnung Registername $\Rightarrow$ RegCode \\
str\_func.c     & Hilfsfunktionen zur Manipulation von Zeichenketten         \\
%\hline
\end{tabular}
\end{center}

\subsection{Debuginformationen}

foobarbaz
