\section{Sprungbefehle}
\label{sec:Sprungbefehle}

Alle Sprungbefehle, außer dem \nameref{opcode:GO} Befehl, veranlassen einen 
relativen Sprung im Programmcode. Relativ im Sinne, dass die Parameter der
Sprungbefehle einen ganzzahligen Versatz zur aktuellen Programmadresse angeben.
Der Versatz\index{Versatz} wird nicht in Bytes angegeben, sondern in
Instruktionen -- wobei eine Instruktion der UMach Maschine 4 Bytes beträgt.
So bedeutet die Instruktion 
\begin{lstlisting}
  BZ -2
\end{lstlisting}
\glqq Fahre 2 Instruktionen rückwärts fort\grqq.


Die Sprungbefehle bauen auf die Vergleichsbefehle auf:
jeder Sprungbefehl (außer \opref{JMP} und \opref{GO}) untersuchen das
Spezialregister \texttt{CMP} und verzweigen die Programmausführung anhand seines
Wertes.


\opdef{BE}{$N \in \mathds{Z}$}{0xD0}{NNN}
\glqq Branch if Equal Zero\grqq.
Wenn das Register \texttt{CMP} den Wert $0$ hat, wird $N$ Instruktionen vorwärts
oder rückwärts fortgefahren. Ein negatives $N$ bedeutet einen Sprung rückwärts,
ein positives $N$ bewirkt einen Sprung vorwärts. Der Sprung wird dadurch
erreicht, dass das Register \texttt{IP} entsprechend modifiziert wird.

\paragraph{Bemerkung}
Die UMach Maschine erhöht den Programmcounter (Register \texttt{IP}) nach
der Ausführung jeder Instruktion
(siehe \ref{subsec:Ausfuehrungszyklus}, Seite
\pageref{subsec:Ausfuehrungszyklus}).
Würde die Maschine diese automatische Erhöhung nicht berücksichtigen, so würde
das Sprungziel um eine Instruktion vorwärts von der automatischen
Erhöhung verschoben. Deshalb muss die Maschine die Zahl $N$ um 1 verringern. Es
ergibt sich die folgende Berechnung des Registers \texttt{IP}:
\[
    IP \gets IP + 4 \cdot (N - 1)
\]
Die Multiplikation mit $4$ wird deshalbt ausgeführt, weil ein Befehl immer aus 4
Bytes besteht, sodass der Adressoffset zwischen zwei Befehlen immer 4 ist. Somit
ist $N$ die Anzahl der zu überspringenden Befehle bis zur nächsten Instruktion.
Der dazu benötigte Offset $N$ wird vom Assembler automatisch berechnet. 

\paragraph{Beispiel}
Der folgende Code lädt zwei Bytes in die Register $R2$ und $R3$ und addiert
diese arithmetisch, falls sie ungleiche Werte haben. Sind die Werte gleich,
wird stattdessen der Inhalt von $R2$ mit 2 multipliziert. Ein mögliches
Überlaufen wird nicht berücksichtigt.
\begin{lstlisting}
  SET   R1 100    # $R1 \gets 100$
  LBUI  R2 R1  0  # Lade Byte von Adresse 100 nach R2
  LBUI  R3 R1  1  # Lade Byte von Adresse 100+1 nach R3
  CMPU  R2 R3     # Vergleiche Inhalt von R2 und R3
                  # Ergebnis geht ins CMP
  #BE    equal    # Asm Schreibweise
  BE    4         # Wenn CMP gleich 0, dann springe 
                  # 4 Instruktionen weiter
                  # (zum label equal)
                  # N ist in diesem Fall 4
  ADDU  R2 R2 R3  # Addiere inhalt von R2 und R3
  SBUI  R2 R1 0   # Speichere R2 nach Adresse 100
  #JMP   finish   # Asm Schreibweise
  JMP   3         # Ueberspringen der folgenden 2 Befehle, 
                  # N von JMP ist 3.
equal:
  MULIU R2 2      # Multipliziere Inhalt von R2 mit 2
  SBUI  LO R1 0   # Speichere Inhalt von LO nach Adresse in R1
finish:
\end{lstlisting}



\opdef{BNE}{$N \in \mathds{Z}$}{0xD1}{NNN}
\glqq Branch if Not Equal Zero\grqq. Entspricht dem Verhalten von \opref{BE} mit dem
Unterschied, dass der angegebene Sprung ausgeführt wird, wenn \texttt{CMP} nicht
$0$ ist.


\opdef{BL}{$N \in \mathds{Z}$}{0xD2}{NNN}
\glqq Branch if Less than Zero\grqq. 
Springt $N$ Instruktionen weiter, wenn der Inhalt von \texttt{CMP} kleiner $0$
ist.


\opdef{BLE}{$N \in \mathds{Z}$}{0xD3}{NNN}
\glqq Branch if Less or Equal Zero\grqq.
Springt $N$ Instruktionen weiter, wenn der Inhalt von \texttt{CMP} kleiner oder
gleich $0$ ist.


\opdef{BG}{$N \in \mathds{Z}$}{0xD4}{NNN}
\glqq Branch if Greater than Zero\grqq.
Springt $N$ Instruktionen weiter, wenn der Inhalt von \texttt{CMP} größer als
$0$ ist.


\opdef{BGE}{$N \in \mathds{Z}$}{0xD5}{NNN}
\glqq Branch if Greater or Equal Zero\grqq. 
Springt $N$ Instruktionen weiter, wenn der Inhalt von \texttt{CMP} größer oder
gleich $0$ ist.


\opdef{JMP}{$N \in \mathds{N}$}{0xD8}{NNN}
\glqq Jump\grqq.
Sprint zum angegebenen Label. Benötigter Offset $N$ wird vom Assembler
automatisch ermittelt.

\opdef{JMPR}{$X \in \Reg$}{0xD9}{R00}
\glqq Jump Register\grqq.
Sprint $X$ Instruktionen weiter oder zurück.
$X$ ist ein Register.


\opdef{GO}{$N \in \mathds{N}$}{0xDF}{NNN}
Setzt $IP$ auf die angegebene absolute Adresse. Hierbei ist zu beachten, dass
nicht in die Mitte eines Befehles gesprungen wird. Dies zu gewährleisten liegt
in der Verantwortung des Programmierers.

