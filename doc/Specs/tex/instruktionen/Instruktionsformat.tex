\section{Instruktionsformate}
\index{Instruktionsformat}

\paragraph{Instruktionsbreite}
\index{Instruktionsbreite}
Jede UMach-Instruktion hat eine feste Bitlänge von 32 Bit (4 mal 8 Bit).
Das gilt unabhängig davon, was die Instruktion tut. Instruktionen, die für ihren
Informationsgehalt weniger als 32 Bit brauchen, wie z.B. \texttt{NOP},
werden mit Nullbits gefüllt. Alle Daten und Informationen, die mit einer
Instruktion übergeben werden, müssen in diesen 32 Bit untergebracht werden.

\paragraph{Byte Order}
\index{Byte Order}
Die Byte Order (Endianness) der gelesenen \glspl{Byte} ist
big-endian, die Byte-Reihenfolge, die für den Mensch selbstverständlich wäre
(von links nach rechts lesen):
die zuerst gelesenen 8 Bits sind die 8 höchstwertigen (Wertigkeiten $2^{31}$ bis
$2^{24}$) und die zuletzt gelesenen Bits sind die niedrigstwertigen
(Wertigkeiten $2^{7}$ bis $2^{0}$).
Bits werden in Stücken von $n$ Bits gelesen, wobei $n = k \cdot 8$ und
$k \in \mathbb{N} \setminus\{0\}$ (Byte für Byte).


\paragraph{Allgemeines Format}
Jede \gls{Instruktion} besteht aus zwei Teilen: der erste Teil ist
8 Bit lang und entspricht dem tatsächlichen \gls{Befehl}, bzw. der Operation,
die von der UMach virtuellen Maschine ausgeführt werden soll.
Dieser 8-Bit-Befehl belegt also die 8 höchstwertigen Bits einer Instruktion.
Die übrigen 24 Bit werden für Operanden oder Daten benutzt. Beispiel einer
Instruktionszerlegung:

\begin{center}
  \begin{tabular}{|l|*{4}{c|}}
    \hline
    Instruktion (32 Bit) &
    \texttt{00000001} & \texttt{00000010} & \texttt{00000011} & \texttt{00000100}
    \\\hline
    Hexa  &
    \texttt{01}   & \texttt{02}   & \texttt{03}   & \texttt{04}
    \\\hline
    Byte Order &
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline
    Interpretation &
    Befehl (8 Bit) &  \multicolumn{3}{c|}{Operanden, Daten oder Füllbits}
    \\\hline
  \end{tabular}
\end{center}

Die Instruktionsformate unterscheiden sich lediglich darin, dass sie die 24 Bits
nach dem 8-Bitigen \gls{Befehl} unterschiedlich verwenden.

In den folgenden Abschnitten werden die UMach-Instruktionsformate vorgestellt.
Jede Angegebene Tabelle gibt in der ersten Zeile die Reihenfolge der Bytes an. 
Alle folgenden Zeilen geben die spezielle Belegung der einzelnen Bytes an.
Falls es mehrere Alternativen zu einer Belegung möglich ist, werden die
Alternativen untereinander aufgelistet (jede in eigener Zeile).
Alle festen Zahlen sind im Hexadezimalsystem angegeben.

\subsection{Format 1}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & \texttt{00} & \texttt{00} & \texttt{00} 
    \\\hline
    Befehl        & \multicolumn{3}{c|}{don't care}
    \\\hline
  \end{tabular}
\end{center}

Der Befehl hat keine Argumenten. Die letzen drei Bytes werden von der Maschine
nicht ausgewertet und sind somit Füllbytes.

\subsection{Format 2}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & \multicolumn{3}{c|}{feste Zahl}
    \\\hline
  \end{tabular}
\end{center}


\subsection{Format 3}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & $Z$ & $R_{1}$ & $R_{2}$ 
    \\\hline
  \end{tabular}
\end{center}

\begin{itemize}
  \item $Z$ ist das Zielregister
  \item $R_{1}$ ist der erste Registeroperand
  \item $R_{2}$ ist der zweite Registeroperand
\end{itemize}


\subsection{Format 4}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & $R$ & \multicolumn{2}{c|}{feste Zahl}
    \\\hline
  \end{tabular}
\end{center}
Das zweite Byte ist ein Register $R$. Die letzten 16 Bits (2 Bytes) sind als eine
Einheit zu betrachten und deren Bedeutung wird dem jeweiligen Befehl überlassen.
