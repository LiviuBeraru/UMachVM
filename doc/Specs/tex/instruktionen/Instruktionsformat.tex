\section{Instruktionsformate}
\index{Instruktionsformat}

\paragraph{Instruktionsbreite}
\index{Instruktionsbreite}
Jede UMach-Instruktion hat eine feste Bitlänge von 32 Bit (4 mal 8 Bit).
Das gilt unabhängig davon, was die Instruktion tut. Instruktionen, die für ihren
Informationsgehalt weniger als 32 Bit brauchen, wie z.B. \texttt{NOP},
werden mit Nullbits gefüllt. Alle Daten und Informationen, die mit einer
Instruktion übergeben werden, müssen in diesen 32 Bit untergebracht werden.

\paragraph{Byte Order}
\index{Byte Order}
Die Byte Order (Endianness) der gelesenen \glspl{Byte} ist
big-endian, die Byte-Reihenfolge, die für den Mensch selbstverständlich wäre
(von links nach rechts lesen):
die zuerst gelesenen 8 Bits sind die 8 höchstwertigen (Wertigkeiten $2^{31}$ bis
$2^{24}$) und die zuletzt gelesenen Bits sind die niedrigstwertigen
(Wertigkeiten $2^{7}$ bis $2^{0}$).
Bits werden in Stücken von $n$ Bits gelesen, wobei $n = k \cdot 8$ und
$k \in \mathbb{N} \setminus\{0\}$ (Byte für Byte).


\paragraph{Allgemeines Format}
Jede \gls{Instruktion} besteht aus zwei Teilen: der erste Teil ist
8 Bit lang und entspricht dem tatsächlichen \gls{Befehl}, bzw. der Operation,
die von der UMach virtuellen Maschine ausgeführt werden soll.
Dieser 8-Bit-Befehl belegt also die 8 höchstwertigen Bits einer Instruktion.
Die übrigen 24 Bit werden für Operanden oder Daten benutzt. Beispiel einer
Instruktionszerlegung:

\begin{center}
  \begin{tabular}{|l|*{4}{c|}}
    \hline
    Instruktion (32 Bit) &
    \texttt{00000001} & \texttt{00000010} & \texttt{00000011} & \texttt{00000100}
    \\\hline
    Hexa  &
    \texttt{01}   & \texttt{02}   & \texttt{03}   & \texttt{04}
    \\\hline
    Byte Order &
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline
    Interpretation &
    Befehl (8 Bit) &  \multicolumn{3}{c|}{Operanden, Daten oder Füllbits}
    \\\hline
  \end{tabular}
\end{center}

Die Instruktionsformate unterscheiden sich lediglich darin, dass sie die 24 Bits
nach dem 8-Bitigen \gls{Befehl} unterschiedlich verwenden.

In den folgenden Abschnitten werden die UMach-Instruktionsformate vorgestellt.
Jede Angegebene Tabelle gibt in der ersten Zeile die Reihenfolge der Bytes an. 
Alle folgenden Zeilen geben die spezielle Belegung der einzelnen Bytes an.
Falls es mehrere Alternativen zu einer Belegung möglich ist, werden die
Alternativen untereinander aufgelistet (jede in eigener Zeile).





\subsection{Op0}
\index{Instruktionsformat!Op0}
\index{Op0}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & \multicolumn{3}{c|}{nicht verwendet}
    \\\hline
  \end{tabular}
\end{center}

Eine Instruktion, die das Format Op0 hat, besteht lediglich aus einem Befehl
ohne Argumenten. Die letzen drei Bytes werden von der Maschine nicht
ausgewertet und sind somit Füllbytes. Es wird empfohlen, die letzten 3 Bytes mit
Nullen zu füllen.
Der Name kommt von \glqq Operation Zero\grqq, ein Befehl gefolgt von Nullen.




\subsection{OpNo}
\index{Instruktionsformat!OpNo}
\index{OpNo}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & \multicolumn{3}{c|}{feste Zahl}
    \\\hline
  \end{tabular}
\end{center}

Die Instruktion im Format OpNo besteht aus einem Befehl im ersten Byte und aus
einer Zahl, die die letzten 3 Bytes belegt. Die Interpretation dieser Zahl wird
dem jeweiligen Befehl überlassen, wird aber meistens eine Adresse oder ein
Versatz bedeuten.
Der Name kommt von \glqq Operation Number\grqq, ein Befehl gefolgt von einer
Zahl.


\subsection{OpRNo}
\index{Instruktionsformat!OpRNo}
\index{OpRNo}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & $R$ & \multicolumn{2}{c|}{feste Zahl}
    \\\hline
  \end{tabular}
\end{center}

Eine Instruktion im Format OpRNo besteht aus einem Befehl, gefolgt von einem
Register, gefolgt von einer festen Zahl, die die letzten 2 Bytes der Instruktion
belegt. Die genaue Interpretation der Zahl wird dem jeweiligen Befehl
überlassen.
Der Name kommt von \glqq Operation Register Number\grqq, ein Befehl, gefolgt von
einem Register, gefolgt von einer Zahl.



\subsection{OpRRNo}
\index{Instruktionsformat!OpRRNo}
\index{OpRR}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & $R_{1}$       & $R_{2}$ & feste Zahl
    \\\hline
  \end{tabular}
\end{center}
Eine Instruktion im Format OpRR besteht aus einem Befehl, gefolgt von der
Angabe zweier Registers, jeweils in einem Byte, gefolgt von einer festen Zahl
im letzten Byte. Das erste Byte wird nicht verwendet.
Der Name kommt von \glqq Operarion Register Register Number\grqq.




\subsection{Op3R}
\index{Instruktionsformat!Op3R}
\index{Op3R}

\begin{center}
  \begin{tabular}{|*{4}{c|}}
    \hline
    erstes Byte   & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Befehl        & $Z$ & $R_{1}$ & $R_{2}$ 
    \\\hline
  \end{tabular}
\end{center}

Eine Instruktion im Format Op3R besteht aus der Angabe eines Befehls im ersten
Byte, gefolgt von der Angabe dreier Register in den jeweiligen folgenden drei
Bytes. Die Register werden als Zahlen angegeben und haben die folgenden
Bedeutungen:
\begin{itemize}
  \item $Z$ ist das Zielregister, wo das Ergebnis der Operation gespeichert
    werden sollte. Die Operation wird vom Befehl angegeben.
  \item $R_{1}$ ist der erste Registeroperand.
  \item $R_{2}$ ist der zweite Registeroperand.
\end{itemize}

Dieses Format entspricht dem folgenden algebraischen Ausdruck:
\[
    Z \gets R_{1} \; (\text{Befehl}) \; R_{2}
\]

Der Name kommt von \glqq Operation 3 Registers\grqq, ein Befehl gefolgt von 3
Registern.




\subsection{Zusammenfassung}
Im folgenden werden die Instruktionsformate tabellarisch zusammengefasst.


\begin{center}
  \begin{tabular}{|l||*{4}{c|}}
    \hline
    Format & erstes Byte & zweites Byte  & drittes Byte  & viertes Byte
    \\\hline\hline
    Op0 & Befehl         & \multicolumn{3}{c|}{nicht verwendet}
    \\\hline
    OpNo & Befehl        & \multicolumn{3}{c|}{feste Zahl}
    \\\hline
    OpRNo & Befehl       & $R$ & \multicolumn{2}{c|}{feste Zahl}
    \\\hline
    OpRR & Befehl        & $R_{1}$       & $R_{2}$ & feste Zahl
    \\\hline
    Op3R & Befehl        & $Z$           & $R_{1}$ & $R_{2}$ 
    \\\hline
  \end{tabular}
\end{center}



