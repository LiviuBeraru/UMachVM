\section{Assembler}

\subsection{Eingabe Dateien}

Es können beliebig viele Programmdateien angegeben werden. Sie werden der
Reiche nach abgearbeitet. Man beachte, dass die Instruktion \texttt{EOP} das
Ende des Programms signalisiert. Falls nachher noch weitere Befehle, eventuell
in anderen Datein, angegeben werden, werden diese zwar assembliert, aber nicht
ausgeführt.

Alles außer Labels is case insensitive. Man kann beliebig Leerzeichen
(whitespace) verwenden.


Siehe den Abschnitt \ref{subsubsec:Funktionen-Beispiel} ab der Seite
\pageref{subsubsec:Funktionen-Beispiel} für ein Beispiel, wo mehrere Dateien
für ein Programm verwendet werden.

\subsection{Labels}
\index{Labels}

Der UMach-Assembler unterstüzt die Verwendung von sogenannten \glqq Labels\grqq,
oder Sprungmarken. Ein Label markiert das Sprungziel für die verschiedenen
Sprungbefehle.

Um ein Label im Programmcode zu definieren, schreibt man den
Labelnamen, gefolgt von einem Doppelpunkt. Zwischen dem Labelnamen und dem
Doppelpunkt können, außer das \glqq newline\grqq-Zeichen, beliebig viele
Leerzeichen eingefügt werden.

Labelname ist höchstens 128 Buchstaben lang.

Labelnamen müssen selbst keine Leerzeichen (whitespace) beinhalten.

Mehrfache Labels, die auf den selben Befehl zeigen, werden unterstüzt. Diese
können beliebing im Code geschrieben werden, d.h. sie können auf verschiedenen
Zeilen oder auf einer einzigen Zeile geschrieben werden. Mehrfache Labels
zeigen jeweils auf den nächsten Befehl. Das Programm \ref{lst:example_labels}
zeigt ein Beispiel für die Verwendung der (mehrfachen) Labels.

\lstinputlisting[caption={Beispiel für Labels},label={lst:example_labels}]
{progs/example_labels.uasm}

In diesem Beispiel zeigen die Labels \texttt{loop}, \texttt{do}, \texttt{it} und
\texttt{now} alle auf den selben Befehl: \texttt{cmp r1 zero}. Zu diesem Befehl
wird gesprungen, indem man einen von diesen Labels verwendet. Hier bewirken
beide Sprungbefehle \texttt{jmp loop} und \texttt{jmp do} einen Sprung zum
selben \texttt{cmp}-Befehl. Die Labels \texttt{finish} und \texttt{end} zeigen
auf den Befehl \texttt{EOP}. Man bemerkt auch die freie Verwendung der
Leerzeichen (über die Lesbarkeit dieses Beispiels lässt sich diskutieren).


\subsection{Programmdaten}
\index{Programmdaten}

Daten werden nach der Anweisung \texttt{.data} angegeben. Diese Anweisung muss
alleine auf einer eigenen Zeile stehen.

Die Programmdaten können auch auf
verschiedenen Programmdateien verteilt werden, sie werden vom Assembler
zusammengefügt und ans Ende der assemblierten Datei eingefügt.

Alle Daten haben jeweils eine Länge, die ein Vielfaches von 4 Byte darstellt.
Bedarft ein Datenelement weniger als $4k$ Bytes, so wird es trotzdem auf
eine Länge von $4 k$ mit Nullbytes gefüllt.

\subsubsection{Strings}
\index{Strings}

String Daten werden mit der Anweisung \texttt{.string}\index{.string} angegeben.
Nach \texttt{.string} kommt der Name des Strings und dann der eigentlich String
zwischen Anführungszeichen. Siehe das Programm \ref{lst:Datenverwendung} für
ein Beispiel.

Strings werden so assembliert, dass sie immer ein Vielfaches von 4 Bytes
belegen. Braucht der textuelle Inhalt des Strings weniger als 4 Byte, so wird
der String mit Nullbytes gefüllt.


\subsubsection{Ganze Zahlen}
\index{Zahlen}

Ganze Zahlen werden mit der Anweisung \texttt{.int}\index{.int} angegeben. Nach
\texttt{.int} folgt der Name (Label) der Zahl, dann die eigentliche Zahl. Diese
kann in Hexa-, Oktal- oder Dezimalsystem angegeben werden, analog wie in der
C/Java Sprache.

\lstinputlisting[caption={Verwendung der Daten},label={lst:Datenverwendung}]
{progs/example_data.uasm}

Angenommen, der Assembler \texttt{uasm}, die virtuelle Maschine
\texttt{umach} und das Programm \texttt{example\_data.uasm} befinden sich im
aktuellen Verzeichniss, kann das Programm \ref{lst:Datenverwendung}  wie folgt
assembliert und ausgeführt werden:
\begin{lstlisting}
./uasm example_data.uasm
./umach u.out
\end{lstlisting}
Es wird lediglig \glqq Hallo Welt\grqq\ ausgegeben.



\subsection{Funktionen}
\index{Funktionen}

\subsubsection{Ausbau einer Funktion}
\blindtext




\subsubsection{Ein Beispiel}
\label{subsubsec:Funktionen-Beispiel}

Das folgende Beispiel verdeutlicht die Verwendung von Funktionen anhand eines
Programms, das die Länge eines Strings berechnet und dieses Länge ausgibt. Der
String ist im Programm selbst einbebettet (Datensegment). Das Programm besteht
aus mehreren Dateien, die jeweils eine Funktion implementieren:
\begin{enumerate}
 \item prog2.uasm, enthält das Hauptprogramm (Programm
       \ref{lst:VerwendungFunktionen}).
 \item strlen.uasm, enthält die Funktion \texttt{strlen}, die die Länge eines
       Strings berechnet (Programm \ref{lst:strlen}).
 \item printint.uasm, enhält die Funktion \texttt{printint}, die eine ganze
       Zahle ausgibt (Programm \ref{lst:printint}).
 \item putchar.uasm, enthält die Funktion \texttt{putchar}, die einen Buchstaben
       ausgibt (Programm \ref{lst:putchar}).
\end{enumerate}


\lstinputlisting[caption={Verwendung der Funktionen},
                 label={lst:VerwendungFunktionen}]
                {progs/prog2.uasm}


\lstinputlisting[caption={Funktion strlen}, label={lst:strlen}]
                {progs/strlen.uasm}


\lstinputlisting[caption={Funktion printint}, label={lst:printint}]
                {progs/printint.uasm}


\lstinputlisting[caption={Funktion putchar}, label={lst:putchar}]
                {progs/putchar.uasm}


Dieses Programm wird wie folgt assembliert:
\begin{lstlisting}
 ./uasm prog2.uasm strlen.uasm printint.uasm putchar.uasm
\end{lstlisting}
Bemerkungen: es werden alle benötigten Dateien angegeben. Die Reihenfolge des
Dateien, die eine Funktion definieren ist egal, die \glqq main\grqq-Datei aber,
die den Startpunkt des Programms beinhaltet muss aber an der ersten Stelle
sein, denn der Code in dieser Datei muss zuerst assembliert werden.

Nach dem Assemblieren wird eine Datei namens \texttt{u.out} erzeugt, die den
\glqq Bytecode\grqq\ für die virtuelle Maschine beinhaltet. Man könnte auch die
Option \texttt{-o} verwenden, um eine alternativen Dateinamen zu spezifizieren.
Möchte man diese Datei ausführen, so könnte man folgendes eingeben:
\begin{lstlisting}
 /umach u.out
\end{lstlisting}
Als Ergebniss bekommt man die Fehlermeldung
\begin{lstlisting}
ERROR: Cannot load 268 bytes of program into 512 bytes of
       memory
ERROR: Cannot load program file u.out.
Aborted
\end{lstlisting}
Das bedeutet, die virtuelle Maschine hat nicht genug Speicher um dieses
Programm überhaupt laden zu können (256 Bytes werden für die Interrupttabelle
reserviert). Man kann in diesem Fall mit der Option \texttt{-m} den Speicher
größer spezifizieren, z.B. so:
\begin{lstlisting}
 /umach -m 600 u.out
\end{lstlisting}
Das erhöht den Speicher auf 600 Bytes. Es wird dann \glqq 12\grqq\ ausgegeben.

Noch eine Bemerkung: es ist zu empfehlen, beim Start der Maschine die Option
\texttt{-v} anzugeben, denn die viele \texttt{PUSH}-Befehle können beim
unzureichenden Speicher einen Stack Overflow verursachen, was derzeit die
Maschine zum Stillstand bringt -- es sei denn, man programmiert einen Interrupt
Handler für den Stack Overflow Interrupt. Der Stack Overflow wird als Warnung
ausgegeben und Warnungen werden erst mit der Option \texttt{-v} ausgegeben.








