\section{Assembler}

\subsection{Eingabe Dateien}

Es können beliebig viele Programmdateien angegeben werden. Sie werden der
Reiche nach abgearbeitet. Man beachte, dass die Instruktion \texttt{EOP} das
Ende des Programms signalisiert. Falls nachher noch weitere Befehle, eventuell
in anderen Datein, angegeben werden, werden diese zwar assembliert, aber nicht
ausgeführt.

Alles außer Labels is case insensitive. Man kann beliebig Leerzeichen
(whitespace) verwenden.


Siehe den Abschnitt \ref{subsubsec:Funktionen-Beispiel} ab der Seite
\pageref{subsubsec:Funktionen-Beispiel} für ein Beispiel, wo mehrere Dateien
für ein Programm verwendet werden.

\subsection{Labels}
\index{Labels}

Der UMach-Assembler unterstüzt die Verwendung von sogenannten \glqq Labels\grqq,
oder Sprungmarken. Ein Label markiert das Sprungziel für die verschiedenen
Sprungbefehle.

Um ein Label im Programmcode zu definieren, schreibt man den
Labelnamen, gefolgt von einem Doppelpunkt. Zwischen dem Labelnamen und dem
Doppelpunkt können, außer das \glqq newline\grqq-Zeichen, beliebig viele
Leerzeichen eingefügt werden.

Labelname ist höchstens 128 Buchstaben lang.

Labelnamen müssen selbst keine Leerzeichen (whitespace) beinhalten.

Mehrfache Labels, die auf den selben Befehl zeigen, werden unterstüzt. Diese
können beliebing im Code geschrieben werden, d.h. sie können auf verschiedenen
Zeilen oder auf einer einzigen Zeile geschrieben werden. Mehrfache Labels
zeigen jeweils auf den nächsten Befehl. Das Programm \ref{lst:example_labels}
zeigt ein Beispiel für die Verwendung der (mehrfachen) Labels.

\lstinputlisting[caption={Beispiel für Labels},label={lst:example_labels}]
{progs/example_labels.uasm}

In diesem Beispiel zeigen die Labels \texttt{loop}, \texttt{do}, \texttt{it} und
\texttt{now} alle auf den selben Befehl: \texttt{cmp r1 zero}. Zu diesem Befehl
wird gesprungen, indem man einen von diesen Labels verwendet. Hier bewirken
beide Sprungbefehle \texttt{jmp loop} und \texttt{jmp do} einen Sprung zum
selben \texttt{cmp}-Befehl. Die Labels \texttt{finish} und \texttt{end} zeigen
auf den Befehl \texttt{EOP}. Man bemerkt auch die freie Verwendung der
Leerzeichen (über die Lesbarkeit dieses Beispiels lässt sich diskutieren).


\subsection{Programmdaten}
\index{Programmdaten}

Daten werden nach der Anweisung \texttt{.data} angegeben. Diese Anweisung muss
alleine auf einer eigenen Zeile stehen.

Die Programmdaten können auch auf
verschiedenen Programmdateien verteilt werden, sie werden vom Assembler
zusammengefügt und ans Ende der assemblierten Datei eingefügt.

Alle Daten haben jeweils eine Länge, die ein Vielfaches von 4 Byte darstellt.
Bedarft ein Datenelement weniger als $4k$ Bytes, so wird es trotzdem auf
eine Länge von $4 k$ mit Nullbytes gefüllt.

\subsubsection{Strings}
\index{Strings}

String Daten werden mit der Anweisung \texttt{.string}\index{.string} angegeben.
Nach \texttt{.string} kommt der Name des Strings und dann der eigentlich String
zwischen Anführungszeichen. Siehe das Programm \ref{lst:Datenverwendung} für
ein Beispiel.

Strings werden so assembliert, dass sie immer ein Vielfaches von 4 Bytes
belegen. Braucht der textuelle Inhalt des Strings weniger als 4 Byte, so wird
der String mit Nullbytes gefüllt.


\subsubsection{Ganze Zahlen}
\index{Zahlen}

Ganze Zahlen werden mit der Anweisung \texttt{.int}\index{.int} angegeben. Nach
\texttt{.int} folgt der Name (Label) der Zahl, dann die eigentliche Zahl. Diese
kann in Hexa-, Oktal- oder Dezimalsystem angegeben werden, analog wie in der
C/Java Sprache.

\lstinputlisting[caption={Verwendung der Daten},label={lst:Datenverwendung}]
{progs/example_data.uasm}

Angenommen, der Assembler \texttt{uasm}, die virtuelle Maschine
\texttt{umach} und das Programm \texttt{example\_data.uasm} befinden sich im
aktuellen Verzeichniss, kann das Programm \ref{lst:Datenverwendung}  wie folgt
assembliert und ausgeführt werden:
\begin{lstlisting}
./uasm example_data.uasm
./umach u.out
\end{lstlisting}
Es wird lediglig \glqq Hallo Welt\grqq\ ausgegeben.



\subsection{Funktionen}
\index{Funktion}

Der UMach Assembler unterstützt die Verwendung von Funktionen.

\subsubsection{Aufbau einer Funktion}
\index{Funktion!Aufbau}

Eine Funktion auf der Assembler-Ebene ist nichts anderes als ein Stück Code,
das mit einem Label versehen ist und dessen letzte Instrution ein \texttt{RET}
ist (von Return). Zu diesem Code wird mit der Anweisung \texttt{CALL}
gesprungen. Der Label ist der Name der Funktion.

Die UMach virtuelle Maschine kennt keine Funktionen, sondern nur einzelne
Maschinenbefehle. Sie kennt also auch keine Argumente, Parameter, Blöcke und
Rückgabewerte. Alle diese Elementen, die in höheren Programmiersprachen eine
Funktion (Methode) ausmachen, müssen also vom Programmierer selbst implementiert
werden. Jeder Programmierer ist also frei in der Entscheidung, wie er diese
Elementen implementiert, wie er überhaupt einem Codeabschnitt Argumente
übergibt, wie er Rückgabewerte darstellt usw. 

Um diese Entscheidungen zu erleichtern kann man einige Konventionen vorstellen,
wie diese Bausteine einer Funktion zu implementieren sind. Eine solche
Konvention wird in den folgenden Punkten gegeben. Man muss aber verstehen, dass
es sich um eine Konvention, bzw. um den Vorschlag einer Konvention handelt.
Jeder ist frei sich andere Konventionen und Regeln auszudenken.

\paragraph{Name der Funktion}
\index{Funktion!Name}
Der Name der Funktion wird als Label angeben. Eine Funktion fängt also wie folgt
an:
\begin{lstlisting}
funktionsname:
    anweisung
    anweisung
    ...
\end{lstlisting}


\paragraph{Ende der Funktion}
\index{Funktion!Ende}
Das Ende der Funktion wird durch den Befehl \texttt{RET} markiert (von
\glqq return\grqq). Für mehr Informationen betreffend dieses Befehls siehe die
Spezifikation der UMach Maschine (Abschnitt 3.8.3).


\paragraph{Argumente}
\index{Funktion!Argumente}

Die Argumente einer Funktion werden vor dem Aufruf auf den Stack abgelegt und
zwar in umgekehrter Reihenfolge\footnote{Dies entspricht übrigens gängiger
Praxis.}. Innerhalb der Funktion werden die Argumente mit Hilfe des Registers
\texttt{SP} (stack pointer) und eines Offsets abgelesen.

Möchte man z.B. eine Funktion namens \texttt{max} mit zwei Argumenten aufrufen
und befindet sich das erste Argument in \texttt{R1} und das zweite in
\texttt{R2}, so pusht man vor dem Aufruf diese zwei Argumente auf den Stack in
umgekehrter Reihenfolge (damit sie die Funktion in richtiger Reihenfolge liest):
\begin{lstlisting}
PUSH R2
PUSH R1
CALL max
\end{lstlisting}
In der Funktion, werden die Adressen der Argumente anhand eines Offsets zum
Register \texttt{SP} berechnet und dann mit dem Befehl \texttt{LW} (load word)
geladen. Dazu muss man auf das folgende aufpassen:
\begin{enumerate}
 \item Der Befehl \texttt{CALL}, mit dem man die Funktion aufruft, pusht die
       Rücksprungadresse aus der Funktion auf den Stack bevor er den Program
       Counter \texttt{PC} verändert. Das ergibt einen zusätzlichen Eintrag 
       auf den Stack.
 \item Jeder Stack Eintrag is 4 Byte groß, egal was da gespeichert wird.
\end{enumerate}
Das ergibt beim Eintritt in die Funktion den folgenden Stack-Layout:
\begin{center}
 \begin{tabular}{ll}
  Adresse     & Inhalt \\\hline
  $\$SP + 0$  & Rücksprungadresse \\
  $\$SP + 4$  & Erstes Argument   \\
  $\$SP + 8$  & Zweites Argument  \\
  \ldots      & \ldots            \\
  $\$SP + 4n$ & $n$. Argument
 \end{tabular}
\end{center}
Um an die zwei Argumente von vorhin zu gelangen, wird also in der Funktion
geschrieben:
\begin{lstlisting}
ADDI R17 SP 4
LW   R17 R17

ADDI R18 SP 8
LW   R18 R18
\end{lstlisting}
Das speichert in das Register \texttt{R17} die Stack-Adresse, wo \texttt{R1}
gepusht wurde und dann gleich aus dieser Adresse wieder in \texttt{R17} den
Wert von \texttt{R1} geladen. Analog für \texttt{R2} und \texttt{R18}.


\paragraph{Rückgabewert}
\index{Funktion!Rückgabewert}
Es gibt viele Möglichkeiten, einen Wert aus einer Funktion zurückzugeben.
Einige davon wären:
\begin{itemize}
 \item Rückgabewert in einem vorgeschriebenen oder vereinbarten Register.
 \item Rückgabewert auf dem Stack, wobei der aufrufende Code vor dem Aufruf
       dafür sorgt, dass entsprechende Stack-Einträge reserviert werden
       (\texttt{SP} dekrementieren).
 \item Rückgabewert auf dem Stack, wobei die Funktion selber den Stack
       manipuliert.
 \item Rückgabe an vorgeschriebener oder vereinbarter Heap-Adresse.
 \item etc.
\end{itemize}
Eine der gängigsten und effizientesten Methoden ist allerdings, den Wert in
einem bestimmten Register abzulegen. Für diese Methode haben wir uns auch
entschieden, und zwar benutzen wir das Register \texttt{R32}, das letze
Register\footnote{Für x86 verwendet man das Register \texttt{eax} für
Rückgabewerte.}. Wird also einen Wert zurückzugeben, so wird er vor dem
\texttt{RET} Befehl in das Register \texttt{R32} kopiert.


\paragraph{Überschreiben der Register}
Es kann sehr schnell passieren, dass eine Funktion Register überschreibt, die
von einer anderen Funktion verwendet werden. Verwendet z.B. eine Funktion die
Register \texttt{R1} bis \texttt{R8} für ihre Berechnungen, und ruft sie
irgendwann eine zweite Funktion auf, die die selben Register verwendet, so
werden in der ersten Funktion die Register verändert, ohne dass sie davon
überhaupt etwas merkt. Ein Beispiel dazu:
\begin{lstlisting}
main:
   SET R1 5
   SET R2 6
   INC R1
   DEC R2
   CALL function
   RET

function:
   CP R3 R1
   CP R1 R2
   CP R2 R3
   RET
\end{lstlisting}

Hier verändert die Funktion \texttt{function} die Werte der Register \texttt{R1}
und \texttt{R2}, die auch von der Funktion \texttt{main} verwendet werden.
Diese Art von unfreiwilliger Überschreibung der Register führt sehr schnell zu
schwer entdeckbaren Fehler. Daher verwenden wir eine Programmiertechnik, die
dieses Problem aufheben sollte: wir überlegen uns vor (oder während) der
Implementierung, welche Register wollen wir benutzen und gleich am Anfang der
Funktion, pushen wir diese Register auf den Stack. Vor dem \texttt{RET} popen
wir die Register wieder zurück (in umgekehrter Reihenfolge). Im nächsten
Beispiel kann man diese Technik sehen.

\paragraph{Beispiel}
Hier ein Beispiel für den Aufruf und Implementierung einer Funktion. Es wird
eine einfache \texttt{max} Funktion implementiert, die die größere aus zwei
Zahlen zurückgibt. Die Rückgabe erfolgt im Register \texttt{R32}.
\lstinputlisting{progs/example_args.uasm}


\subsubsection{Ein größeres Beispiel}
\label{subsubsec:Funktionen-Beispiel}

Das folgende Beispiel verdeutlicht die Verwendung von Funktionen anhand eines
Programms, das die Länge eines Strings berechnet und dieses Länge ausgibt. Der
String ist im Programm selbst einbebettet (Datensegment). Das Programm besteht
aus mehreren Dateien, die jeweils eine Funktion implementieren:
\begin{enumerate}
 \item prog2.uasm, enthält das Hauptprogramm (Programm
       \ref{lst:VerwendungFunktionen}).
 \item strlen.uasm, enthält die Funktion \texttt{strlen}, die die Länge eines
       Strings berechnet (Programm \ref{lst:strlen}).
 \item printint.uasm, enhält die Funktion \texttt{printint}, die eine ganze
       Zahle ausgibt (Programm \ref{lst:printint}).
 \item putchar.uasm, enthält die Funktion \texttt{putchar}, die einen Buchstaben
       ausgibt (Programm \ref{lst:putchar}).
\end{enumerate}


\lstinputlisting[caption={Verwendung der Funktionen},
                 label={lst:VerwendungFunktionen}]
                {progs/prog2.uasm}


\lstinputlisting[caption={Funktion strlen}, label={lst:strlen}]
                {progs/strlen.uasm}


\lstinputlisting[caption={Funktion printint}, label={lst:printint}]
                {progs/printint.uasm}


\lstinputlisting[caption={Funktion putchar}, label={lst:putchar}]
                {progs/putchar.uasm}


Dieses Programm wird wie folgt assembliert:
\begin{lstlisting}
 ./uasm prog2.uasm strlen.uasm printint.uasm putchar.uasm
\end{lstlisting}
Bemerkungen: es werden alle benötigten Dateien angegeben. Die Reihenfolge des
Dateien, die eine Funktion definieren ist egal, die \glqq main\grqq-Datei aber,
die den Startpunkt des Programms beinhaltet muss aber an der ersten Stelle
sein, denn der Code in dieser Datei muss zuerst assembliert werden.

Nach dem Assemblieren wird eine Datei namens \texttt{u.out} erzeugt, die den
\glqq Bytecode\grqq\ für die virtuelle Maschine beinhaltet. Man könnte auch die
Option \texttt{-o} verwenden, um eine alternativen Dateinamen zu spezifizieren.
Möchte man diese Datei ausführen, so könnte man folgendes eingeben:
\begin{lstlisting}
 /umach u.out
\end{lstlisting}
Als Ergebniss bekommt man die Fehlermeldung
\begin{lstlisting}
ERROR: Cannot load 268 bytes of program into 512 bytes of
       memory
ERROR: Cannot load program file u.out.
Aborted
\end{lstlisting}
Das bedeutet, die virtuelle Maschine hat nicht genug Speicher um dieses
Programm überhaupt laden zu können (256 Bytes werden für die Interrupttabelle
reserviert). Man kann in diesem Fall mit der Option \texttt{-m} den Speicher
größer spezifizieren, z.B. so:
\begin{lstlisting}
 /umach -m 600 u.out
\end{lstlisting}
Das erhöht den Speicher auf 600 Bytes. Es wird dann \glqq 12\grqq\ ausgegeben.

Noch eine Bemerkung: es ist zu empfehlen, beim Start der Maschine die Option
\texttt{-v} anzugeben, denn die viele \texttt{PUSH}-Befehle können beim
unzureichenden Speicher einen Stack Overflow verursachen, was derzeit die
Maschine zum Stillstand bringt -- es sei denn, man programmiert einen Interrupt
Handler für den Stack Overflow Interrupt. Der Stack Overflow wird als Warnung
ausgegeben und Warnungen werden erst mit der Option \texttt{-v} ausgegeben.








